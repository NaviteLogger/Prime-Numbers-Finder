     1                                  section .text
     2                                      org 100h
     3                                  
     4                                  start:
     5 00000000 31C0                        xor ax, ax
     6 00000002 31DB                        xor bx, bx
     7 00000004 31C9                        xor cx, cx
     8 00000006 31D2                        xor dx, dx
     9                                  
    10 00000008 E82600                      call get_input       ; Pobierz zakres od użytkownika
    11 0000000B BA[7300]                    mov dx, after_input
    12 0000000E E8F500                      call print_string
    13 00000011 E82001                      call new_line
    14 00000014 E85500                      call find_primes     ; Znajdź liczby pierwsze
    15 00000017 E81A01                      call new_line
    16 0000001A EBE4                        jmp start            ; Powtarzaj operację dla nowych zakresów
    17                                  
    18 0000001C B44C                        mov ah, 0x4c 
    19 0000001E CD21                        int 21h
    20                                  
    21                                  end:
    22 00000020 E81101                      call new_line
    23 00000023 BA[FA00]                    mov dx, end_msg
    24 00000026 E8DD00                      call print_string
    25 00000029 E80801                      call new_line
    26 0000002C B84C00                      mov ax, 4Ch
    27 0000002F CD21                        int 21h
    28                                  
    29                                  ;----------------------------------------------
    30                                  ; Procedura: get_input
    31                                  ; Pobiera zakres od użytkownika
    32                                  ;----------------------------------------------
    33                                  get_input:
    34                                      ; Pobierz minimalną wartość
    35 00000031 BA[0000]                    mov dx, prompt1        ; 1. Załaduj adres `prompt1` do rejestru DX
    36 00000034 E8CF00                      call print_string      ; 2. Wywołaj procedurę `print_string` (wypisuje "Enter min value:")
    37 00000037 E88200                      call get_number        ; 3. Wywołaj procedurę `get_number`, aby pobrać liczbę od użytkownika
    38                                  
    39                                      ; Zapisz wartość w zmiennej `min`
    40 0000003A 891E[0000]                  mov [min], bx          ; 4. Zapisz wartość z rejestru AX do zmiennej `min`
    41 0000003E BB0000                      mov bx, 0              ; 5. Wyzeruj BX
    42                                  
    43                                      ; Pobierz maksymalną wartość
    44 00000041 BA[1500]                    mov dx, prompt2
    45 00000044 E8BF00                      call print_string
    46 00000047 E87200                      call get_number
    47 0000004A 891E[0200]                  mov [max], bx    ; Zapisz wartość w `max`
    48                                  
    49                                      ; Sprawdź, czy min < max
    50 0000004E A1[0000]                    mov ax, [min]
    51 00000051 3B06[0200]                  cmp ax, [max]
    52 00000055 7D0A                        jge invalid_range
    53                                  
    54                                      ; Debugowanie to moja pasja
    55 00000057 BA[2A00]                    mov dx, valid_range
    56 0000005A E8A900                      call print_string
    57 0000005D E8D400                      call new_line
    58                                  
    59 00000060 C3                          ret
    60                                  
    61                                  invalid_range:
    62 00000061 BA[BE00]                    mov dx, invalid_range_msg
    63 00000064 E89F00                      call print_string
    64 00000067 E8CA00                      call new_line
    65                                      
    66 0000006A EBC5                        jmp get_input
    67                                      
    68                                  
    69                                  ;----------------------------------------------
    70                                  ; Procedura: find_primes
    71                                  ; Znajduje liczby pierwsze w zadanym przedziale
    72                                  ;----------------------------------------------
    73                                  find_primes:
    74 0000006C A1[0000]                    mov ax, [min] ; Zaczynamy od dolnej granicy
    75 0000006F EB00                        jmp next_number
    76                                      
    77                                  next_number:
    78 00000071 3B06[0200]                  cmp ax, [max]    ; Czy dojechaliśmy za górną granicę?
    79 00000075 7F1D                        jg done          ; Jeśli tak, zakończ
    80                                  
    81 00000077 50                          push ax          ; Zachowaj wartość na stosie
    82 00000078 E81A00                      call is_prime    ; Sprawdź, czy liczba jest pierwsza
    83 0000007B 58                          pop ax           ; Przywróć wartość ze stosu
    84                                  
    85 0000007C 83FB01                      cmp bx, 1        ; Jeśli BX = 1, to liczba jest pierwsza
    86 0000007F 7510                        jne skip_number
    87                                  
    88                                      ; Wyświetl liczbę pierwszą
    89 00000081 BA[EC00]                    mov dx, prime_msg
    90 00000084 E87F00                      call print_string
    91                                      
    92 00000087 89C2                        mov dx, ax
    93 00000089 E88100                      call print_number
    94 0000008C E8A500                      call new_line
    95 0000008F EB00                        jmp skip_number
    96                                  
    97                                  skip_number:
    98 00000091 40                          inc ax           ; Przejdź do następnej liczby
    99 00000092 EBDD                        jmp next_number
   100                                  
   101                                  done:
   102 00000094 C3                          ret
   103                                  
   104                                  ;----------------------------------------------
   105                                  ; Procedura: is_prime
   106                                  ; Sprawdza, czy liczba w AX jest pierwsza
   107                                  ; Zwraca wynik w BX (1 = pierwsza, 0 = niepierwsza)
   108                                  ;----------------------------------------------
   109                                  is_prime:
   110 00000095 BB0200                      mov bx, 2  ; bx - pierwszy dzielnik
   111                                      
   112 00000098 83F801                      cmp ax, 1  ; 1 nie jest liczbą pierwszą
   113 0000009B 7E1B                        jng not_a_prime
   114                                  
   115 0000009D 89C1                        mov cx, ax ; cx - górna granica dzielników
   116 0000009F EB00                        jmp check_divisor
   117                                  
   118                                  check_divisor:
   119 000000A1 39CB                        cmp bx, cx
   120 000000A3 7D0F                        jge prime_found   ; Jeśli bx >= cx, liczba jest pierwsza
   121                                  
   122                                      ; Sprawdź, czy ax jest podzielne przez bx
   123 000000A5 89C8                        mov ax, cx
   124 000000A7 BA0000                      mov dx, 0
   125 000000AA F7F3                        div bx
   126                                      
   127 000000AC 83FA00                      cmp dx, 0
   128 000000AF 7407                        je not_a_prime    ; Jeśli reszta = 0, to liczba nie jest pierwsza
   129                                  
   130 000000B1 43                          inc bx            ; Sprawdź kolejny dzielnik
   131 000000B2 EBED                        jmp check_divisor
   132                                  
   133                                  prime_found:
   134 000000B4 BB0100                      mov bx, 1         ; Liczba jest pierwsza
   135 000000B7 C3                          ret
   136                                  
   137                                  not_a_prime:
   138 000000B8 BB0000                      mov bx, 0         ; Liczba nie jest pierwsza
   139 000000BB C3                          ret
   140                                  
   141                                  ;----------------------------------------------
   142                                  ; Procedura: get_number
   143                                  ; Pobiera liczbę od użytkownika
   144                                  ; Zwraca wynik w AX
   145                                  ;----------------------------------------------
   146                                  get_number:
   147 000000BC 31C0                        xor ax, ax         ; Wyzeruj AX, aby nie było śmieci
   148 000000BE 31DB                        xor bx, bx         ; Wyzeruj BX (będzie używany do przechowywania liczby)
   149                                  
   150                                  read_digit:
   151 000000C0 B401                        mov ah, 1          ; Funkcja DOS do odczytu znaku z klawiatury
   152 000000C2 CD21                        int 21h            ; Pobierz znak od użytkownika
   153 000000C4 B400                        mov ah, 0          ; Wyzeruj rejestr AH
   154                                      
   155 000000C6 3C0D                        cmp al, 13         ; Sprawdź, czy Enter (kod ASCII 13)
   156 000000C8 743B                        je done_input      ; Jeśli Enter, zakończ wczytywanie
   157                                  
   158                                      ; Zabezpieczenie przed wprowadzeniem złegu znaku
   159 000000CA 3C23                        cmp al, "#"        ; Znak kończący program
   160 000000CC 0F8450FF                    je end
   161                                  
   162 000000D0 3C30                        cmp al, "0"        ; Sprawdź, czy znak jest cyfrą
   163 000000D2 7C22                        jl invalid_input   ; Jeśli nie, zignoruj
   164                                  
   165 000000D4 3C39                        cmp al, "9"        ; Sprawdź, czy znak jest cyfrą
   166 000000D6 7F1E                        jg invalid_input   ; Jeśli nie, zignoruj
   167                                  
   168 000000D8 2C30                        sub al, "0"        ; Konwertuj znak ASCII na cyfrę
   169 000000DA 53                          push bx            ; Zachowaj wartość na stosie
   170 000000DB 6BDB0A                      imul bx, 10        ; Przesuń w lewo bx o 1 miejsce   
   171                                      
   172                                      ; Dodanie dx do ax
   173 000000DE 01C3                        add bx, ax         ; Dodaj wartość do BX
   174 000000E0 59                          pop cx             ; Odczytaj wartość ze stosu
   175                                  
   176 000000E1 39CB                        cmp bx, cx         ; Sprawdź, czy nowa wartość mieści się w 16 bitach
   177                                      ; technicznie w 15, bo pierwszy jest na znak (?)
   178 000000E3 7C02                        jl overflow        ; Jeśli nie, zignoruj
   179                                  
   180 000000E5 EBD9                        jmp read_digit     ; Kontynuuj wczytywanie kolejnych cyfr
   181                                      
   182                                  overflow:
   183 000000E7 E84A00                      call new_line
   184 000000EA BA[3D00]                    mov dx, overflow_msg
   185 000000ED E81600                      call print_string
   186 000000F0 E84100                      call new_line
   187 000000F3 E90AFF                      jmp start
   188                                      
   189                                  invalid_input:
   190 000000F6 E83B00                      call new_line
   191 000000F9 BA[9400]                    mov dx, invalid_char_msg
   192 000000FC E80700                      call print_string
   193 000000FF E83200                      call new_line
   194 00000102 E9FBFE                      jmp start
   195                                  
   196                                  
   197                                  done_input:
   198 00000105 C3                          ret
   199                                  
   200                                  ;----------------------------------------------
   201                                  ; Procedura: print_string
   202                                  ; Wypisuje string zakończony znakiem $
   203                                  ;----------------------------------------------
   204                                  print_string:
   205 00000106 50                          push ax
   206 00000107 B409                        mov ah, 9
   207 00000109 CD21                        int 21h
   208 0000010B 58                          pop ax
   209 0000010C C3                          ret
   210                                  
   211                                  ;----------------------------------------------
   212                                  ; Procedura: print_number
   213                                  ; Wypisuje liczbę z AX
   214                                  ;----------------------------------------------
   215                                  print_number:
   216 0000010D 50                          push ax
   217 0000010E BB0A00                      mov bx, 10
   218 00000111 EB00                        jmp print_digit
   219                                      
   220                                  print_digit:
   221 00000113 89D0                        mov ax, dx
   222 00000115 31D2                        xor dx, dx
   223 00000117 F7F3                        div bx ; Ax - to co wypisujemy, dx - reszta, którą wypiszemy później
   224                                  
   225 00000119 83F800                      cmp ax, 0
   226 0000011C 740D                        je end_print_digit
   227                                  
   228 0000011E 52                          push dx ; Zachowanie reszty na stosie
   229                                      
   230 0000011F 89C2                        mov dx, ax
   231 00000121 83C230                      add dx, "0"    ; Konwersja cyfry na znak
   232 00000124 B402                        mov ah, 2
   233 00000126 CD21                        int 21h
   234                                  
   235 00000128 5A                          pop dx ; Odczytanie reszty ze stosu
   236                                  
   237                                      
   238 00000129 EBE8                        jmp print_digit
   239                                  
   240                                  end_print_digit:
   241 0000012B 83C230                      add dx, "0"
   242 0000012E B402                        mov ah, 2
   243 00000130 CD21                        int 21h
   244                                  
   245 00000132 58                          pop ax
   246 00000133 C3                          ret
   247                                  
   248                                  ;----------------------------------------------
   249                                  ; Procedura: new_line
   250                                  ; Wypisuje nową linię
   251                                  ;----------------------------------------------
   252                                  new_line:
   253 00000134 BA[0B01]                    mov dx, newline
   254 00000137 E8CCFF                      call print_string
   255 0000013A C3                          ret
   256                                  
   257                                  ;----------------------------------------------
   258                                  ; Sekcja .data - inicjalizowane zmienne
   259                                  ;----------------------------------------------
   260                                  section .data
   261 00000000 577069737A20646F6C-         prompt1 db "Wpisz dolny zakres: $"
   261 00000009 6E79207A616B726573-
   261 00000012 3A2024             
   262 00000015 577069737A20676F72-         prompt2 db "Wpisz gorny zakres: $"
   262 0000001E 6E79207A616B726573-
   262 00000027 3A2024             
   263 0000002A 5A616B726573207072-         valid_range db "Zakres prawidlowy!$"
   263 00000033 617769646C6F777921-
   263 0000003C 24                 
   264 0000003D 5770726F7761647A6F-         overflow_msg db "Wprowadzona liczba jest zbyt duza. Wprowadz mniejsza.$"
   264 00000046 6E61206C69637A6261-
   264 0000004F 206A657374207A6279-
   264 00000058 742064757A612E2057-
   264 00000061 70726F7761647A206D-
   264 0000006A 6E69656A737A612E24 
   265 00000073 4C69637A6279207069-         after_input db "Liczby pierwsze z przedzialu to:$"
   265 0000007C 657277737A65207A20-
   265 00000085 70727A65647A69616C-
   265 0000008E 7520746F3A24       
   266 00000094 4E6965707261776964-         invalid_char_msg db "Nieprawidlowy znak. Wprowadz tylko cyfry.$"
   266 0000009D 6C6F7779207A6E616B-
   266 000000A6 2E205770726F776164-
   266 000000AF 7A2074796C6B6F2063-
   266 000000B8 796672792E24       
   267 000000BE 4E6965707261776964-         invalid_range_msg db "Nieprawidlowy zakres. Wprowadz dolny < gorny.$"
   267 000000C7 6C6F7779207A616B72-
   267 000000D0 65732E205770726F77-
   267 000000D9 61647A20646F6C6E79-
   267 000000E2 203C20676F726E792E-
   267 000000EB 24                 
   268 000000EC 4C2E20706965727773-         prime_msg db "L. pierwsza: $"
   268 000000F5 7A613A2024         
   269 000000FA 4B6F6E696563207072-         end_msg db "Koniec programu.$"
   269 00000103 6F6772616D752E24   
   270 0000010B 0D0A24                      newline db 13, 10, '$'
   271                                  
   272                                  ;----------------------------------------------
   273                                  ; Sekcja .bss - niezainicjalizowane zmienne
   274                                  ;----------------------------------------------
   275                                  section .bss
   276 00000000 ????                        min resb 2
   277 00000002 ????                        max resb 2
